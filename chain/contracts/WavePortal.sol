// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.4;

import "hardhat/console.sol";

// Note: Use no or only minimal notes in production. Notes bloat contract size.
// Optimizations: https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6
// Functions, even internal, use additional gas. Don't be functional.
contract WavePortal {
    uint256 totalWaves;
    uint256 private seed; // For generating random numbers

    // events log information publically. For example, this will be logged in the transaction history on etherscan.io
    // https://hackernoon.com/how-to-use-events-in-solidity-pe1735t5
    // provides an easy way to trigger the frontend by watching for the event.
    // Allows significantly cheaper data storage than storing in a contract variable;
    // however, logs cannot be accessed by a contract.
    // Index by the term you will most often use to lookup the log from. You can index by up to (3) parameters.
    event NewWave(address indexed from, uint256 timestamp, string message, bool didWin);

    struct Wave {
        address sender;
        string message;
        uint256 timestamp;
    }

    Wave[] waves;

    
    // Store last time an address waved.
    mapping(address => uint256) public lastWavedAt;
    

    // Payable allows contract to receive payment
    constructor() payable {
        console.log("Let's make this smart contract.");

        /* 
        Inits the random number seed.
        Logic is to use the sum of two hard-to-predict numbers, then cast them to a number <= 100;
        each subsequent seed is generated by the same function + the previous seed.
         */
        seed = (block.timestamp + block.difficulty) % 100;
    }

    // injests a message from the frontend
    function wave(string memory _message) public {
        // First check it's been at least 15 minutes since last wave.
        require(lastWavedAt[msg.sender] + 15 minutes < block.timestamp, "Wait 15 minutes");
        // Update last wave for sender.
        lastWavedAt[msg.sender] = block.timestamp;


        totalWaves += 1;
        console.log("%s has waved and sent the message: %s", msg.sender, _message);

        waves.push(Wave(msg.sender, _message, block.timestamp));

        seed = (block.timestamp + block.difficulty + seed) % 100; // gen new seed

        if (seed < 50) {
            console.log("%s won!", msg.sender);

            uint256 prizeAmount = 0.0001 ether;
            require (prizeAmount <= address(this).balance, "Contract has insufficient funds");

            (bool success, ) = (msg.sender).call{ value: prizeAmount }("");

            require(success, "Failed to withdraw money from contract.");

            emit NewWave(msg.sender, block.timestamp, _message, true);
        } else {
            emit NewWave(msg.sender, block.timestamp, _message, false);
        }
    }

    function getTotalWaves() public view returns (uint256) {
        console.log("To date, %d waves have been sent!", totalWaves);
        return totalWaves;
    }

    function getAllWaves() public view returns (Wave[] memory) {
        return waves;
    }
}